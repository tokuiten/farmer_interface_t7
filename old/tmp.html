// ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢åˆ¤å®šï¼ˆæ‹¡å¼µå®šç¾©ï¼‰
        function isInCentralArea(x, y) {
            const centralY = offsetY + LANE_LENGTH + CENTRAL_WIDTH / 2;
            const centralAreaTop = centralY - CENTRAL_WIDTH / 2;
            const centralAreaBottom = centralY + CENTRAL_WIDTH / 2;
            
            // Yåº§æ¨™ãŒä¸­å¤®é€šè·¯ã®å¹…å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            return y >= centralAreaTop && y <= centralAreaBottom;
        }
        
        // ãƒ­ãƒœãƒƒãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function isRobotInCentralArea(robotId) {
            const robot = robots[robotId];
            if (!robot) return false;
            
            return isInCentralArea(robot.x, robot.y);
        }
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã‚’é€šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function segmentInvolvesCentralArea(segment) {
            if (!segment || !isValidPoint(segment.from) || !isValidPoint(segment.to)) {
                return false;
            }
            
            // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®é–‹å§‹ç‚¹ã¾ãŸã¯çµ‚äº†ç‚¹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã‚ã‚‹
            return isInCentralArea(segment.from.x, segment.from.y) || 
                   isInCentralArea(segment.to.x, segment.to.y);
        }        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢åˆ¤å®šï¼ˆæ‹¡å¼µå®šç¾©ï¼‰
        function isInCentralArea(x, y) {
            const centralY = offsetY + LANE_LENGTH + CENTRAL_WIDTH / 2;
            const centralAreaTop = centralY - CENTRAL_WIDTH / 2;
            const centralAreaBottom = centralY + CENTRAL_WIDTH / 2;
            
            // Yåº§æ¨™ãŒä¸­å¤®é€šè·¯ã®å¹…å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            return y >= centralAreaTop && y <= centralAreaBottom;
        }
        
        // ãƒ­ãƒœãƒƒãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function isRobotInCentralArea(robotId) {
            const robot = robots[robotId];
            if (!robot) return false;
            
            return isInCentralArea(robot.x, robot.y);
        }
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã‚’é€šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function segmentInvolvesCentralArea(segment) {
            if (!segment || !isValidPoint(segment.from) || !isValidPoint(segment.to)) {
                return false;
            }
            
            // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®é–‹å§‹ç‚¹ã¾ãŸã¯çµ‚äº†ç‚¹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã‚ã‚‹
            return isInCentralArea(segment.from.x, segment.from.y) || 
                   isInCentralArea(segment.to.x, segment.to.y);
        }        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆ
        function generateAnimationPaths() {
            try {
                generateRobotAnimationPath('robot1', currentPaths.robot1);
                generateRobotAnimationPath('robot2', currentPaths.robot2);
            } catch (error) {
                console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                throw error;
            }
        }<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¾²å ´ãƒãƒƒãƒ—ã¨ãƒ­ãƒœãƒƒãƒˆçµŒè·¯ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f8ff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .version-info {
            text-align: right;
            color: #e74c3c;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #fff3cd;
            border-radius: 5px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .robot-controls {
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background-color: #f8f9fa;
        }
        .robot-row {
            display: flex;
            gap: 15px;
            align-items: end;
            flex-wrap: wrap;
        }
        .control-group {
            display: inline-block;
            margin: 5px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 12px;
        }
        select, button {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            margin-left: 10px;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        #animateBtn {
            background-color: #3498db;
        }
        #animateBtn:hover:not(:disabled) {
            background-color: #2980b9;
        }
        #stopBtn {
            background-color: #e74c3c;
        }
        #stopBtn:hover:not(:disabled) {
            background-color: #c0392b;
        }
        .control-buttons {
            text-align: center;
            margin-top: 20px;
        }
        #map {
            background: white;
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #2196F3;
        }
        .path-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 4px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸšœ è¾²å ´ãƒãƒƒãƒ—ã¨ãƒ­ãƒœãƒƒãƒˆçµŒè·¯ã‚·ã‚¹ãƒ†ãƒ </h1>
        <div class="version-info">
            Version 2.8.1 - 2025/07/17 - é–¢æ•°å®šç¾©ã‚¨ãƒ©ãƒ¼ä¿®æ­£ç‰ˆ (ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢åˆ¤å®šé–¢æ•°ã®å®šç¾©ä½ç½®ä¿®æ­£)
        </div>
        
        <div class="controls">
            <div class="robot-controls">
                <h3>ğŸ¤– ãƒ­ãƒœãƒƒãƒˆ1 è¨­å®š</h3>
                <div class="robot-row">
                    <div class="control-group">
                        <label for="startArea1">é–‹å§‹ã‚¨ãƒªã‚¢:</label>
                        <select id="startArea1">
                            <option value="1">ã‚¨ãƒªã‚¢1</option>
                            <option value="2">ã‚¨ãƒªã‚¢2</option>
                            <option value="3">ã‚¨ãƒªã‚¢3</option>
                            <option value="4">ã‚¨ãƒªã‚¢4</option>
                            <option value="5">ã‚¨ãƒªã‚¢5</option>
                            <option value="6">ã‚¨ãƒªã‚¢6</option>
                            <option value="7">ã‚¨ãƒªã‚¢7</option>
                            <option value="8">ã‚¨ãƒªã‚¢8</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="startLane1">é–‹å§‹é€šè·¯:</label>
                        <select id="startLane1">
                            <option value="1">é€šè·¯1</option>
                            <option value="2">é€šè·¯2</option>
                            <option value="3">é€šè·¯3</option>
                            <option value="4">é€šè·¯4</option>
                            <option value="5">é€šè·¯5</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="endArea1">çµ‚äº†ã‚¨ãƒªã‚¢:</label>
                        <select id="endArea1">
                            <option value="1">ã‚¨ãƒªã‚¢1</option>
                            <option value="2">ã‚¨ãƒªã‚¢2</option>
                            <option value="3">ã‚¨ãƒªã‚¢3</option>
                            <option value="4">ã‚¨ãƒªã‚¢4</option>
                            <option value="5">ã‚¨ãƒªã‚¢5</option>
                            <option value="6">ã‚¨ãƒªã‚¢6</option>
                            <option value="7">ã‚¨ãƒªã‚¢7</option>
                            <option value="8">ã‚¨ãƒªã‚¢8</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="endLane1">çµ‚äº†é€šè·¯:</label>
                        <select id="endLane1">
                            <option value="1">é€šè·¯1</option>
                            <option value="2">é€šè·¯2</option>
                            <option value="3">é€šè·¯3</option>
                            <option value="4">é€šè·¯4</option>
                            <option value="5">é€šè·¯5</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="direction1">å›è»¢æ–¹å‘:</label>
                        <select id="direction1">
                            <option value="right">æ™‚è¨ˆå›ã‚Š</option>
                            <option value="left">åæ™‚è¨ˆå›ã‚Š</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="robot-controls">
                <h3>ğŸ¤– ãƒ­ãƒœãƒƒãƒˆ2 è¨­å®š</h3>
                <div class="robot-row">
                    <div class="control-group">
                        <label for="startArea2">é–‹å§‹ã‚¨ãƒªã‚¢:</label>
                        <select id="startArea2">
                            <option value="1">ã‚¨ãƒªã‚¢1</option>
                            <option value="2">ã‚¨ãƒªã‚¢2</option>
                            <option value="3">ã‚¨ãƒªã‚¢3</option>
                            <option value="4">ã‚¨ãƒªã‚¢4</option>
                            <option value="5" selected>ã‚¨ãƒªã‚¢5</option>
                            <option value="6">ã‚¨ãƒªã‚¢6</option>
                            <option value="7">ã‚¨ãƒªã‚¢7</option>
                            <option value="8">ã‚¨ãƒªã‚¢8</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="startLane2">é–‹å§‹é€šè·¯:</label>
                        <select id="startLane2">
                            <option value="1">é€šè·¯1</option>
                            <option value="2">é€šè·¯2</option>
                            <option value="3">é€šè·¯3</option>
                            <option value="4">é€šè·¯4</option>
                            <option value="5">é€šè·¯5</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="endArea2">çµ‚äº†ã‚¨ãƒªã‚¢:</label>
                        <select id="endArea2">
                            <option value="1">ã‚¨ãƒªã‚¢1</option>
                            <option value="2">ã‚¨ãƒªã‚¢2</option>
                            <option value="3">ã‚¨ãƒªã‚¢3</option>
                            <option value="4">ã‚¨ãƒªã‚¢4</option>
                            <option value="5">ã‚¨ãƒªã‚¢5</option>
                            <option value="6">ã‚¨ãƒªã‚¢6</option>
                            <option value="7">ã‚¨ãƒªã‚¢7</option>
                            <option value="8" selected>ã‚¨ãƒªã‚¢8</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="endLane2">çµ‚äº†é€šè·¯:</label>
                        <select id="endLane2">
                            <option value="1">é€šè·¯1</option>
                            <option value="2">é€šè·¯2</option>
                            <option value="3">é€šè·¯3</option>
                            <option value="4">é€šè·¯4</option>
                            <option value="5" selected>é€šè·¯5</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="direction2">å›è»¢æ–¹å‘:</label>
                        <select id="direction2">
                            <option value="right">æ™‚è¨ˆå›ã‚Š</option>
                            <option value="left" selected>åæ™‚è¨ˆå›ã‚Š</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="control-buttons">
                <button onclick="calculatePaths()">çµŒè·¯è¨ˆç®—ï¼ˆ2å°ï¼‰</button>
                <button onclick="clearPath()">ã‚¯ãƒªã‚¢</button>
                <button onclick="startAnimation()" id="animateBtn" disabled>ğŸ¤– ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹</button>
                <button onclick="stopAnimation()" id="stopBtn" disabled>â¹ åœæ­¢</button>
            </div>
        </div>
        
        <canvas id="map" width="1000" height="600"></canvas>
        
        <div class="info">
            <h3>è¾²å ´ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä»•æ§˜</h3>
            <p><strong>ã‚¨ãƒªã‚¢æ§‹æˆ:</strong> 1ã€œ4ï¼ˆåŒ—å´ï¼‰ã€5ã€œ8ï¼ˆå—å´ï¼‰ã€å„ã‚¨ãƒªã‚¢ã«5æœ¬ã®é€šè·¯</p>
            <p><strong>é€šè·¯ä»•æ§˜:</strong> å¹…1mã€é•·ã•25mã€é€šè·¯é–“1mã€å—åŒ—æ–¹å‘</p>
            <p><strong>ä¸­å¤®é€šè·¯:</strong> å¹…2mã€æ±è¥¿æ–¹å‘ã€å…¨ã‚¨ãƒªã‚¢ã‚’æ¥ç¶šï¼ˆé€šè·¯ä¾µå…¥éƒ¨ã‚‚å«ã‚€ï¼‰</p>
            <p><strong>è¡çªå›é¿:</strong> ãƒ­ãƒœãƒƒãƒˆ1ãŒå„ªå…ˆæ¨©ã‚’æŒã¡ã€ãƒ­ãƒœãƒƒãƒˆ2ã¯ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥å‰ã«å¾…æ©Ÿ</p>
        </div>
        
        <div id="pathInfo" class="path-info" style="display: none;">
            <h4>ğŸ¤– ãƒ­ãƒœãƒƒãƒˆçµŒè·¯æƒ…å ±</h4>
            <div id="pathDetails"></div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å®šç¾©
        const canvas = document.getElementById('map');
        const ctx = canvas.getContext('2d');
        
        // åº§æ¨™ç³»è¨­å®š
        const scale = 10;
        const offsetX = 50;
        const offsetY = 50;
        
        // è¾²å ´ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•°
        const LANE_WIDTH = 1 * scale;
        const LANE_LENGTH = 25 * scale;
        const LANE_SPACING = 1 * scale;
        const CENTRAL_WIDTH = 2 * scale;
        const AREA_WIDTH = 5 * (LANE_WIDTH + LANE_SPACING) - LANE_SPACING;
        
        // ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹ç®¡ç†ï¼ˆãƒã‚°ä¿®æ­£ç‰ˆï¼‰
        let robots = {
            robot1: {
                x: 0, y: 0, angle: 0, currentStep: 0,
                animationPath: [], color: '#e74c3c', name: 'ãƒ­ãƒœãƒƒãƒˆ1',
                state: 'idle', waitCounter: 0, priority: 1,
                segmentProgress: 0, // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…é€²è¡Œåº¦ã‚’è¿½åŠ 
                lastUpdateTime: 0   // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç®¡ç†ç”¨
            },
            robot2: {
                x: 0, y: 0, angle: 0, currentStep: 0,
                animationPath: [], color: '#2ecc71', name: 'ãƒ­ãƒœãƒƒãƒˆ2',
                state: 'idle', waitCounter: 0, priority: 2,
                segmentProgress: 0,
                lastUpdateTime: 0
            }
        };
        
        let currentPaths = { robot1: null, robot2: null };
        let animationId = null;
        let isAnimating = false;
        let lastFrameTime = 0; // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆç®¡ç†ç”¨
        
        // åŸºæœ¬æç”»é–¢æ•°
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawCentralPath();
            
            for (let area = 1; area <= 8; area++) {
                drawArea(area);
            }
            
            drawLabels();
        }
        
        function drawCentralPath() {
            const centralY = offsetY + LANE_LENGTH + CENTRAL_WIDTH / 2;
            const startX = offsetX;
            const endX = offsetX + 4 * AREA_WIDTH;
            
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(startX, centralY - CENTRAL_WIDTH / 2, endX - startX, CENTRAL_WIDTH);
            
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, centralY - CENTRAL_WIDTH / 2, endX - startX, CENTRAL_WIDTH);
            
            ctx.fillStyle = '#d35400';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ä¸­å¤®é€šè·¯', startX + (endX - startX) / 2, centralY + 5);
        }
        
        function drawArea(areaNum) {
            const isNorth = areaNum <= 4;
            const col = (areaNum - 1) % 4;
            
            const areaX = offsetX + col * AREA_WIDTH;
            const areaY = isNorth ? offsetY : offsetY + LANE_LENGTH + CENTRAL_WIDTH;
            
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            const labelY = isNorth ? areaY - 10 : areaY + LANE_LENGTH + 25;
            ctx.fillText(`ã‚¨ãƒªã‚¢${areaNum}`, areaX + AREA_WIDTH / 2, labelY);
            
            for (let lane = 1; lane <= 5; lane++) {
                drawLane(areaNum, lane, areaX, areaY, isNorth);
            }
        }
        
        function drawLane(areaNum, laneNum, areaX, areaY, isNorth) {
            const laneX = areaX + (laneNum - 1) * (LANE_WIDTH + LANE_SPACING);
            
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(laneX, areaY, LANE_WIDTH, LANE_LENGTH);
            
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.strokeRect(laneX, areaY, LANE_WIDTH, LANE_LENGTH);
            
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            const textY = isNorth ? areaY + LANE_LENGTH - 5 : areaY + 15;
            ctx.fillText(laneNum.toString(), laneX + LANE_WIDTH / 2, textY);
        }
        
        function drawLabels() {
            ctx.fillStyle = '#34495e';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            
            ctx.fillText('åŒ—', offsetX - 30, offsetY + LANE_LENGTH / 2);
            ctx.fillText('å—', offsetX - 30, offsetY + LANE_LENGTH + CENTRAL_WIDTH + LANE_LENGTH / 2);
            ctx.fillText('è¥¿', offsetX + 2 * AREA_WIDTH - 10, offsetY + 2 * LANE_LENGTH + CENTRAL_WIDTH + 30);
            ctx.fillText('æ±', offsetX + 4 * AREA_WIDTH - 20, offsetY + 2 * LANE_LENGTH + CENTRAL_WIDTH + 30);
        }
        
        // åº§æ¨™è¨ˆç®—é–¢æ•°
        function getIntersectionPoint(area, lane) {
            const isNorth = area <= 4;
            const col = (area - 1) % 4;
            
            const areaX = offsetX + col * AREA_WIDTH;
            const laneX = areaX + (lane - 1) * (LANE_WIDTH + LANE_SPACING) + LANE_WIDTH / 2;
            const centralY = offsetY + LANE_LENGTH + CENTRAL_WIDTH / 2;
            
            return { x: laneX, y: centralY };
        }
        
        function getLaneEndPoint(area, lane) {
            const isNorth = area <= 4;
            const col = (area - 1) % 4;
            
            const areaX = offsetX + col * AREA_WIDTH;
            const laneX = areaX + (lane - 1) * (LANE_WIDTH + LANE_SPACING) + LANE_WIDTH / 2;
            
            let endY;
            if (isNorth) {
                endY = offsetY;
            } else {
                endY = offsetY + LANE_LENGTH + CENTRAL_WIDTH + LANE_LENGTH;
            }
            
            return { x: laneX, y: endY };
        }
        
        function calculateAngle(from, to) {
            return Math.atan2(to.y - from.y, to.x - from.x);
        }
        
        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢åˆ¤å®šé–¢æ•°ç¾¤ï¼ˆå®šç¾©ä½ç½®ä¿®æ­£ï¼‰
        function isInCentralArea(x, y) {
            const centralY = offsetY + LANE_LENGTH + CENTRAL_WIDTH / 2;
            const centralAreaTop = centralY - CENTRAL_WIDTH / 2;
            const centralAreaBottom = centralY + CENTRAL_WIDTH / 2;
            
            // Yåº§æ¨™ãŒä¸­å¤®é€šè·¯ã®å¹…å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            return y >= centralAreaTop && y <= centralAreaBottom;
        }
        
        // ãƒ­ãƒœãƒƒãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function isRobotInCentralArea(robotId) {
            const robot = robots[robotId];
            if (!robot) return false;
            
            return isInCentralArea(robot.x, robot.y);
        }
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã‚’é€šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function segmentInvolvesCentralArea(segment) {
            if (!segment || !isValidPoint(segment.from) || !isValidPoint(segment.to)) {
                return false;
            }
            
            // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®é–‹å§‹ç‚¹ã¾ãŸã¯çµ‚äº†ç‚¹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã‚ã‚‹
            return isInCentralArea(segment.from.x, segment.from.y) || 
                   isInCentralArea(segment.to.x, segment.to.y);
        }
        
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆã®çµŒè·¯è¨ˆç®—
        function calculatePaths() {
            try {
                const robot1Config = {
                    startArea: parseInt(document.getElementById('startArea1').value),
                    startLane: parseInt(document.getElementById('startLane1').value),
                    endArea: parseInt(document.getElementById('endArea1').value),
                    endLane: parseInt(document.getElementById('endLane1').value),
                    direction: document.getElementById('direction1').value
                };
                
                const robot2Config = {
                    startArea: parseInt(document.getElementById('startArea2').value),
                    startLane: parseInt(document.getElementById('startLane2').value),
                    endArea: parseInt(document.getElementById('endArea2').value),
                    endLane: parseInt(document.getElementById('endLane2').value),
                    direction: document.getElementById('direction2').value
                };
                
                // å…¥åŠ›å€¤æ¤œè¨¼
                if (!validateConfig(robot1Config) || !validateConfig(robot2Config)) {
                    console.error('ç„¡åŠ¹ãªè¨­å®šå€¤ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ');
                    return;
                }
                
                const workSequence1 = generateWorkSequence(robot1Config);
                const workSequence2 = generateWorkSequence(robot2Config);
                
                if (!workSequence1.length || !workSequence2.length) {
                    console.error('ä½œæ¥­ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                    return;
                }
                
                currentPaths = {
                    robot1: { ...robot1Config, workSequence: workSequence1 },
                    robot2: { ...robot2Config, workSequence: workSequence2 }
                };
                
                drawMap();
                drawMultiRobotPaths();
                showMultiRobotPathInfo();
                
                try {
                    generateAnimationPaths();
                } catch (pathError) {
                    console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆã§è¿½åŠ ã‚¨ãƒ©ãƒ¼:', pathError);
                    throw pathError;
                }
                
                document.getElementById('animateBtn').disabled = false;
                
            } catch (error) {
                console.error('çµŒè·¯è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                alert('çµŒè·¯è¨ˆç®—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            }
        }
        
        // è¨­å®šå€¤æ¤œè¨¼é–¢æ•°
        function validateConfig(config) {
            const { startArea, startLane, endArea, endLane, direction } = config;
            
            if (isNaN(startArea) || startArea < 1 || startArea > 8) return false;
            if (isNaN(endArea) || endArea < 1 || endArea > 8) return false;
            if (isNaN(startLane) || startLane < 1 || startLane > 5) return false;
            if (isNaN(endLane) || endLane < 1 || endLane > 5) return false;
            if (!['right', 'left'].includes(direction)) return false;
            
            return true;
        }
        
        function generateWorkSequence(config) {
            const { startArea, startLane, endArea, endLane, direction } = config;
            const sequence = [];
            
            if (startArea === endArea) {
                const lanes = [];
                if (direction === 'right') {
                    for (let lane = startLane; lane <= endLane; lane++) {
                        lanes.push(lane);
                    }
                } else {
                    for (let lane = startLane; lane >= endLane; lane--) {
                        lanes.push(lane);
                    }
                }
                
                lanes.forEach(lane => {
                    sequence.push({ area: startArea, lane: lane, action: 'work' });
                });
            } else {
                const areas = getAreaSequence(startArea, endArea, direction);
                
                areas.forEach((area, areaIndex) => {
                    let startLaneForArea, endLaneForArea;
                    
                    if (area === startArea) {
                        startLaneForArea = startLane;
                        if (direction === 'right') {
                            endLaneForArea = area <= 4 ? 5 : 1;
                        } else {
                            endLaneForArea = area <= 4 ? 1 : 5;
                        }
                    } else if (area === endArea) {
                        const isNorthArea = area <= 4;
                        const prevArea = areas[areaIndex - 1];
                        const prevIsNorth = prevArea <= 4;
                        
                        if (isNorthArea === prevIsNorth) {
                            if (isNorthArea) {
                                startLaneForArea = direction === 'right' ? 1 : 5;
                            } else {
                                startLaneForArea = direction === 'right' ? 5 : 1;
                            }
                        } else {
                            if (isNorthArea) {
                                startLaneForArea = direction === 'right' ? 1 : 5;
                            } else {
                                startLaneForArea = direction === 'right' ? 5 : 1;
                            }
                        }
                        endLaneForArea = endLane;
                    } else {
                        const isNorthArea = area <= 4;
                        const prevArea = areas[areaIndex - 1];
                        const prevIsNorth = prevArea <= 4;
                        
                        if (isNorthArea === prevIsNorth) {
                            if (isNorthArea) {
                                startLaneForArea = direction === 'right' ? 1 : 5;
                                endLaneForArea = direction === 'right' ? 5 : 1;
                            } else {
                                startLaneForArea = direction === 'right' ? 5 : 1;
                                endLaneForArea = direction === 'right' ? 1 : 5;
                            }
                        } else {
                            if (isNorthArea) {
                                startLaneForArea = direction === 'right' ? 1 : 5;
                                endLaneForArea = direction === 'right' ? 5 : 1;
                            } else {
                                startLaneForArea = direction === 'right' ? 5 : 1;
                                endLaneForArea = direction === 'right' ? 1 : 5;
                            }
                        }
                    }
                    
                    if (startLaneForArea <= endLaneForArea) {
                        for (let lane = startLaneForArea; lane <= endLaneForArea; lane++) {
                            sequence.push({ area: area, lane: lane, action: 'work' });
                        }
                    } else {
                        for (let lane = startLaneForArea; lane >= endLaneForArea; lane--) {
                            sequence.push({ area: area, lane: lane, action: 'work' });
                        }
                    }
                });
            }
            
            return sequence;
        }
        
        function getAreaSequence(startArea, endArea, direction) {
            const clockwiseOrder = [1, 2, 3, 4, 8, 7, 6, 5];
            const counterClockwiseOrder = [1, 5, 6, 7, 8, 4, 3, 2];
            
            const order = direction === 'right' ? clockwiseOrder : counterClockwiseOrder;
            
            const startIndex = order.indexOf(startArea);
            const endIndex = order.indexOf(endArea);
            
            const sequence = [];
            let currentIndex = startIndex;
            
            sequence.push(order[currentIndex]);
            
            while (order[currentIndex] !== endArea) {
                currentIndex = (currentIndex + 1) % order.length;
                sequence.push(order[currentIndex]);
            }
            
            return sequence;
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆé–¢æ•°ï¼ˆä¿®æ­£ä½ç½®ï¼‰
        function generateAnimationPaths() {
            try {
                generateRobotAnimationPath('robot1', currentPaths.robot1);
                generateRobotAnimationPath('robot2', currentPaths.robot2);
            } catch (error) {
                console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                throw error;
            }
        }
        
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆ
        function generateRobotAnimationPath(robotId, pathData) {
            try {
                if (!pathData || !pathData.workSequence || !Array.isArray(pathData.workSequence)) {
                    console.error(`${robotId}: ç„¡åŠ¹ãªãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿`);
                    return;
                }
                
                const animPath = [];
                const sequence = pathData.workSequence;
                
                sequence.forEach((work, index) => {
                    // ä½œæ¥­ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
                    if (!work || typeof work.area !== 'number' || typeof work.lane !== 'number') {
                        console.error(`${robotId}: ç„¡åŠ¹ãªä½œæ¥­ãƒ‡ãƒ¼ã‚¿ at index ${index}`, work);
                        return;
                    }
                    
                    const intersectionPoint = getIntersectionPoint(work.area, work.lane);
                    const endPoint = getLaneEndPoint(work.area, work.lane);
                    
                    // åº§æ¨™ã®æ¤œè¨¼
                    if (!isValidPoint(intersectionPoint) || !isValidPoint(endPoint)) {
                        console.error(`${robotId}: ç„¡åŠ¹ãªåº§æ¨™ at index ${index}`);
                        return;
                    }
                    
                    if (index > 0) {
                        const prevWork = sequence[index - 1];
                        const prevIntersection = getIntersectionPoint(prevWork.area, prevWork.lane);
                        
                        if (isValidPoint(prevIntersection)) {
                            animPath.push({
                                type: 'transition',
                                from: { x: prevIntersection.x, y: prevIntersection.y },
                                to: { x: intersectionPoint.x, y: intersectionPoint.y },
                                workIndex: index,
                                robotId: robotId
                            });
                        }
                    }
                    
                    animPath.push({
                        type: 'outbound',
                        from: { x: intersectionPoint.x, y: intersectionPoint.y },
                        to: { x: endPoint.x, y: endPoint.y },
                        workIndex: index,
                        robotId: robotId
                    });
                    
                    animPath.push({
                        type: 'return',
                        from: { x: endPoint.x, y: endPoint.y },
                        to: { x: intersectionPoint.x, y: intersectionPoint.y },
                        workIndex: index,
                        robotId: robotId
                    });
                });
                
                robots[robotId].animationPath = animPath;
                
                if (animPath.length > 0 && isValidPoint(animPath[0].from)) {
                    robots[robotId].x = animPath[0].from.x;
                    robots[robotId].y = animPath[0].from.y;
                    robots[robotId].currentStep = 0;
                    robots[robotId].segmentProgress = 0;
                    robots[robotId].angle = calculateAngle(animPath[0].from, animPath[0].to);
                    robots[robotId].state = 'working';
                    robots[robotId].waitCounter = 0;
                } else {
                    console.error(`${robotId}: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¹ãŒç©ºã¾ãŸã¯ç„¡åŠ¹`);
                }
                
            } catch (error) {
                console.error(`${robotId}: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµŒè·¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼:`, error);
            }
        }
        
        // åº§æ¨™æ¤œè¨¼é–¢æ•°
        function isValidPoint(point) {
            return point && 
                   typeof point.x === 'number' && 
                   typeof point.y === 'number' && 
                   isFinite(point.x) && 
                   isFinite(point.y);
        }
        
        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢æ‹¡å¼µå¯¾å¿œã®è¡çªå›é¿ã‚·ã‚¹ãƒ†ãƒ 
        function canProceed(robotId, segment) {
            try {
                const robot = robots[robotId];
                const otherRobotId = robotId === 'robot1' ? 'robot2' : 'robot1';
                const otherRobot = robots[otherRobotId];
                
                if (!robot || !otherRobot || !segment) {
                    console.error(`${robotId}: è¡çªå›é¿åˆ¤å®šã§nullãƒ‡ãƒ¼ã‚¿æ¤œå‡º`);
                    return false;
                }
                
                // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‹ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‹ãƒã‚§ãƒƒã‚¯
                if (segment.type === 'transition' || segmentInvolvesCentralArea(segment)) {
                    
                    // ç›¸æ‰‹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆä½ç½®ãƒ™ãƒ¼ã‚¹ï¼‰
                    if (isRobotInCentralArea(otherRobotId)) {
                        console.log(`${robotId}: ç›¸æ‰‹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ä½¿ç”¨ä¸­ã®ãŸã‚å¾…æ©Ÿ`);
                        return false;
                    }
                    
                    // ç›¸æ‰‹ãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‹å‹•ä½œã‚’ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆçŠ¶æ…‹ãƒ™ãƒ¼ã‚¹ï¼‰
                    if (otherRobot.state === 'in_central' || otherRobot.state === 'requesting_central') {
                        // ã•ã‚‰ã«è©³ç´°ãƒã‚§ãƒƒã‚¯ï¼šç›¸æ‰‹ã®ç¾åœ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‹ã‹
                        const otherCurrentSegment = otherRobot.animationPath[otherRobot.currentStep];
                        if (otherCurrentSegment && 
                            (otherCurrentSegment.type === 'transition' || segmentInvolvesCentralArea(otherCurrentSegment))) {
                            
                            // å„ªå…ˆåº¦ã§åˆ¤å®š
                            if (robot.priority > otherRobot.priority) {
                                console.log(`${robotId}: å„ªå…ˆåº¦ãŒä½ã„ãŸã‚å¾…æ©Ÿ`);
                                return false;
                            }
                        }
                    }
                    
                    console.log(`${robotId}: ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥è¨±å¯`);
                    return true;
                }
                
                return true; // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‰ãªã„å‹•ä½œã¯å¸¸ã«è¨±å¯
                
            } catch (error) {
                console.error(`${robotId}: è¡çªå›é¿åˆ¤å®šã‚¨ãƒ©ãƒ¼:`, error);
                return false; // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨ã®ãŸã‚å¾…æ©Ÿ
            }
        }
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ç‰ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡
        function startAnimation() {
            try {
                if (!robots.robot1.animationPath || !robots.robot1.animationPath.length || 
                    !robots.robot2.animationPath || !robots.robot2.animationPath.length) {
                    console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¹ãŒç„¡åŠ¹ã§ã™');
                    return;
                }
                
                isAnimating = true;
                lastFrameTime = performance.now();
                
                // ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹åˆæœŸåŒ–
                Object.keys(robots).forEach(robotId => {
                    const robot = robots[robotId];
                    robot.currentStep = 0;
                    robot.segmentProgress = 0;
                    robot.state = 'working';
                    robot.waitCounter = 0;
                    robot.lastUpdateTime = lastFrameTime;
                });
                
                document.getElementById('animateBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                animate();
                
            } catch (error) {
                console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
                stopAnimation();
            }
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isAnimating = false;
            document.getElementById('animateBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            try {
                drawMap();
                if (currentPaths.robot1 && currentPaths.robot2) {
                    drawMultiRobotPaths();
                }
            } catch (error) {
                console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢æ™‚ã®æç”»ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        function animate(currentTime) {
            if (!isAnimating) {
                stopAnimation();
                return;
            }
            
            try {
                // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡ï¼ˆ60FPSï¼‰
                const deltaTime = currentTime - lastFrameTime;
                if (deltaTime < 16.67) { // ç´„60FPS
                    animationId = requestAnimationFrame(animate);
                    return;
                }
                lastFrameTime = currentTime;
                
                const robot1Complete = robots.robot1.currentStep >= robots.robot1.animationPath.length;
                const robot2Complete = robots.robot2.currentStep >= robots.robot2.animationPath.length;
                
                if (robot1Complete && robot2Complete) {
                    stopAnimation();
                    return;
                }
                
                // ãƒ­ãƒœãƒƒãƒˆç§»å‹•å‡¦ç†
                if (!robot1Complete) {
                    moveRobot('robot1', deltaTime);
                }
                
                if (!robot2Complete) {
                    moveRobot('robot2', deltaTime);
                }
                
                // æç”»ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡ä»˜ãï¼‰
                if (deltaTime >= 16.67) {
                    renderFrame();
                }
                
                animationId = requestAnimationFrame(animate);
                
            } catch (error) {
                console.error('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
                stopAnimation();
            }
        }
        
        // æç”»æœ€é©åŒ–
        function renderFrame() {
            try {
                drawMap();
                if (currentPaths.robot1 && currentPaths.robot2) {
                    drawMultiRobotPaths();
                }
                drawRobots();
            } catch (error) {
                console.error('ãƒ•ãƒ¬ãƒ¼ãƒ æç”»ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢æ‹¡å¼µå¯¾å¿œã®ãƒ­ãƒœãƒƒãƒˆç§»å‹•å‡¦ç†
        function moveRobot(robotId, deltaTime = 16.67) {
            try {
                const robot = robots[robotId];
                
                // å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                if (!robot || !robot.animationPath || robot.currentStep >= robot.animationPath.length) {
                    return;
                }
                
                const currentSegment = robot.animationPath[robot.currentStep];
                
                if (!currentSegment || !isValidPoint(currentSegment.from) || !isValidPoint(currentSegment.to)) {
                    console.error(`${robotId}: ç„¡åŠ¹ãªã‚»ã‚°ãƒ¡ãƒ³ãƒˆ at step ${robot.currentStep}`);
                    robot.currentStep++;
                    return;
                }
                
                const speed = 2; // ãƒ”ã‚¯ã‚»ãƒ«/ãƒ•ãƒ¬ãƒ¼ãƒ 
                
                // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‹å‹•ä½œã®å‡¦ç†
                const involvesCentralArea = currentSegment.type === 'transition' || segmentInvolvesCentralArea(currentSegment);
                
                if (involvesCentralArea) {
                    // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«å…¥ã‚‹å‰ã¾ãŸã¯å…¥ã£ã¦ã„ã‚‹é–“ã®å‡¦ç†
                    
                    // ã¾ã ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«å…¥ã£ã¦ã„ãªã„å ´åˆ
                    if (!isRobotInCentralArea(robotId) && robot.segmentProgress === 0) {
                        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥è¦æ±‚çŠ¶æ…‹ã«å¤‰æ›´
                        if (robot.state !== 'requesting_central' && robot.state !== 'waiting_at_lane') {
                            robot.state = 'requesting_central';
                        }
                        
                        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                        if (!canProceed(robotId, currentSegment)) {
                            robot.state = 'waiting_at_lane'; // é€šè·¯å†…ã§å¾…æ©Ÿ
                            robot.waitCounter++;
                            return; // é€šè·¯å†…ã§åœæ­¢
                        }
                        
                        // é€²å…¥è¨±å¯ãŒå‡ºãŸå ´åˆ
                        robot.state = 'in_central';
                    }
                    
                    // æ—¢ã«ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«ã„ã‚‹ã‹ç§»å‹•ä¸­ã®å ´åˆ
                    if (robot.state === 'in_central' || isRobotInCentralArea(robotId)) {
                        robot.state = 'in_central';
                        // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ç§»å‹•ç¶™ç¶š
                    } else {
                        // é€šè·¯å†…å¾…æ©Ÿä¸­ã®å†ãƒã‚§ãƒƒã‚¯
                        if (canProceed(robotId, currentSegment)) {
                            robot.state = 'in_central';
                        } else {
                            robot.waitCounter++;
                            return; // é€šè·¯å†…ã§å¾…æ©Ÿç¶™ç¶š
                        }
                    }
                } else {
                    // ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ã«é–¢ã‚ã‚‰ãªã„é€šè·¯å†…ä½œæ¥­
                    if (robot.state !== 'working') {
                        robot.state = 'working';
                    }
                }
                
                // ç§»å‹•è¨ˆç®—ã®ç²¾åº¦å‘ä¸Š
                const dx = currentSegment.to.x - currentSegment.from.x;
                const dy = currentSegment.to.y - currentSegment.from.y;
                const totalDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (totalDistance < 0.1) { // æ¥µå°è·é›¢ã®å‡¦ç†
                    robot.x = currentSegment.to.x;
                    robot.y = currentSegment.to.y;
                    robot.currentStep++;
                    robot.segmentProgress = 0;
                    onSegmentComplete(robotId, currentSegment);
                    return;
                }
                
                // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé€²è¡Œåº¦ãƒ™ãƒ¼ã‚¹ã®ç§»å‹•
                const moveDistance = speed;
                robot.segmentProgress += moveDistance / totalDistance;
                
                if (robot.segmentProgress >= 1.0) {
                    // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå®Œäº†
                    robot.x = currentSegment.to.x;
                    robot.y = currentSegment.to.y;
                    robot.currentStep++;
                    robot.segmentProgress = 0;
                    onSegmentComplete(robotId, currentSegment);
                } else {
                    // ä¸­é–“ä½ç½®è¨ˆç®—
                    robot.x = currentSegment.from.x + dx * robot.segmentProgress;
                    robot.y = currentSegment.from.y + dy * robot.segmentProgress;
                    robot.angle = calculateAngle(currentSegment.from, currentSegment.to);
                }
                
                robot.waitCounter = 0; // ç§»å‹•æ™‚ã¯å¾…æ©Ÿã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒªã‚»ãƒƒãƒˆ
                
            } catch (error) {
                console.error(`${robotId}: ç§»å‹•å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
                // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æ¬¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«é€²ã‚€
                robots[robotId].currentStep++;
            }
        }
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå®Œäº†æ™‚ã®çŠ¶æ…‹ç®¡ç†æ”¹å–„
        function onSegmentComplete(robotId, segment) {
            try {
                const robot = robots[robotId];
                
                if (!robot || !segment) {
                    console.error(`${robotId}: onSegmentComplete ã§ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿`);
                    return;
                }
                
                // çŠ¶æ…‹é·ç§»ã®æ˜ç¢ºåŒ–
                switch (segment.type) {
                    case 'transition':
                        robot.state = 'working'; // ä¸­å¤®é€šè·¯ç§»å‹•å®Œäº† â†’ ä½œæ¥­çŠ¶æ…‹
                        break;
                    case 'outbound':
                    case 'return':
                        robot.state = 'working'; // é€šè·¯å†…ä½œæ¥­å®Œäº† â†’ ä½œæ¥­çŠ¶æ…‹ç¶­æŒ
                        break;
                    default:
                        console.warn(`${robotId}: æœªçŸ¥ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚¿ã‚¤ãƒ—: ${segment.type}`);
                        robot.state = 'working';
                }
                
                robot.waitCounter = 0;
                robot.segmentProgress = 0;
                
            } catch (error) {
                console.error(`${robotId}: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå®Œäº†å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, error);
            }
        }
        
        function drawRobots() {
            drawRobot(robots.robot1);
            drawRobot(robots.robot2);
        }
        
        function drawRobot(robot) {
            if (robot.currentStep >= robot.animationPath.length) return;
            
            const size = 8;
            
            ctx.save();
            ctx.translate(robot.x, robot.y);
            ctx.rotate(robot.angle);
            
            let fillColor = robot.color;
            let strokeColor = robot.color === '#e74c3c' ? '#c0392b' : '#27ae60';
            
            if (robot.state === 'waiting_at_lane') {
                const blinkCycle = Math.floor(robot.waitCounter / 15) % 2;
                if (blinkCycle === 0) {
                    fillColor = '#f39c12';
                    strokeColor = '#e67e22';
                }
            }
            
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(-size/2, size/2);
            ctx.lineTo(-size/2, -size/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
            
            // çŠ¶æ…‹è¡¨ç¤º
            ctx.fillStyle = robot.color;
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            const stateText = getStateDisplayText(robot.state);
            ctx.fillText(`${robot.name.slice(-1)}:${stateText}`, robot.x, robot.y - 15);
            
            if (robot.state === 'waiting_at_lane' && robot.waitCounter > 0) {
                ctx.fillStyle = '#f39c12';
                ctx.font = '8px Arial';
                ctx.fillText(`é€šè·¯å¾…æ©Ÿ${Math.floor(robot.waitCounter/30)}s`, robot.x, robot.y - 25);
            }
        }
        
        function getStateDisplayText(state) {
            switch(state) {
                case 'working': return 'ä½œæ¥­';
                case 'requesting_central': return 'è¦æ±‚';
                case 'in_central': return 'ç§»å‹•';
                case 'waiting': return 'å¾…æ©Ÿ'; // ä¸­å¤®é€šè·¯ã§ã®å¾…æ©Ÿï¼ˆæ—§ä»•æ§˜ï¼‰
                case 'waiting_at_lane': return 'é€šè·¯å¾…æ©Ÿ'; // é€šè·¯å†…ã§ã®å¾…æ©Ÿï¼ˆæ–°ä»•æ§˜ï¼‰
                default: return state;
            }
        }
        
        // çµŒè·¯æç”»
        function drawMultiRobotPaths() {
            if (!currentPaths.robot1 || !currentPaths.robot2) return;
            
            drawRobotPath(currentPaths.robot1, robots.robot1.color, 1);
            drawRobotPath(currentPaths.robot2, robots.robot2.color, 2);
        }
        
        function drawRobotPath(pathData, color, robotNum) {
            if (!pathData || !pathData.workSequence) return;
            
            const sequence = pathData.workSequence;
            
            sequence.forEach((work, index) => {
                const intersectionPoint = getIntersectionPoint(work.area, work.lane);
                const endPoint = getLaneEndPoint(work.area, work.lane);
                
                ctx.fillStyle = color;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                const offsetY = robotNum === 1 ? -15 : -25;
                ctx.fillText(`R${robotNum}-${index + 1}`, intersectionPoint.x, intersectionPoint.y + offsetY);
                
                drawRobotWorkRoute(intersectionPoint, endPoint, index, color, robotNum);
            });
            
            drawRobotTransitionPaths(sequence, color, robotNum);
        }
        
        function drawRobotWorkRoute(startPoint, endPoint, workIndex, color, robotNum) {
            const lineWidth = robotNum === 1 ? 2 : 1.5;
            const offset = robotNum === 1 ? 0 : 3;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(startPoint.x + offset, startPoint.y);
            ctx.lineTo(endPoint.x + offset, endPoint.y);
            ctx.stroke();
            
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(endPoint.x + offset, endPoint.y);
            ctx.lineTo(startPoint.x + offset, startPoint.y);
            ctx.stroke();
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(endPoint.x + offset, endPoint.y, 3, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawRobotTransitionPaths(sequence, color, robotNum) {
            if (sequence.length < 2) return;
            
            const offset = robotNum === 1 ? 0 : 5;
            
            for (let i = 0; i < sequence.length - 1; i++) {
                const currentWork = sequence[i];
                const nextWork = sequence[i + 1];
                
                const currentPoint = getIntersectionPoint(currentWork.area, currentWork.lane);
                const nextPoint = getIntersectionPoint(nextWork.area, nextWork.lane);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(currentPoint.x + offset, currentPoint.y);
                ctx.lineTo(nextPoint.x + offset, nextPoint.y);
                ctx.stroke();
            }
        }
        
        // æƒ…å ±è¡¨ç¤º
        function showMultiRobotPathInfo() {
            if (!currentPaths.robot1 || !currentPaths.robot2) return;
            
            let pathDetails = '<div style="display: flex; gap: 20px;">';
            
            pathDetails += generateRobotPathInfo(currentPaths.robot1, robots.robot1, '1');
            pathDetails += generateRobotPathInfo(currentPaths.robot2, robots.robot2, '2');
            
            pathDetails += '</div>';
            
            pathDetails += `
                <p><strong>è¡çªå›é¿:</strong> ãƒ­ãƒœãƒƒãƒˆIDå„ªå…ˆæ–¹å¼ï¼ˆãƒ­ãƒœãƒƒãƒˆ1ãŒå„ªå…ˆæ¨©ã€ä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ï¼é€šè·¯ä¾µå…¥éƒ¨ã‚‚å«ã‚€ï¼‰</p>
                <p><strong>å‡¡ä¾‹:</strong></p>
                <ul>
                    <li>ğŸ”´ èµ¤: ãƒ­ãƒœãƒƒãƒˆ1ã®çµŒè·¯ï¼ˆå„ªå…ˆæ¨©ã‚ã‚Šï¼‰</li>
                    <li>ğŸŸ¢ ç·‘: ãƒ­ãƒœãƒƒãƒˆ2ã®çµŒè·¯ï¼ˆä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥å‰å¾…æ©Ÿï¼‰</li>
                    <li>å®Ÿç·š: å¾€è·¯ã€ç ´ç·š: å¾©è·¯ã€å¤ªç ´ç·š: é€šè·¯é–“ç§»å‹•</li>
                    <li>ğŸŸ  ã‚ªãƒ¬ãƒ³ã‚¸ç‚¹æ»…: é€šè·¯å†…å¾…æ©ŸçŠ¶æ…‹</li>
                </ul>
                <p><strong>çŠ¶æ…‹è¡¨ç¤º:</strong> ä½œæ¥­ï¼ˆé€šè·¯å†…ï¼‰ã€è¦æ±‚ï¼ˆä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥è¦æ±‚ï¼‰ã€ç§»å‹•ï¼ˆä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢ç§»å‹•ä¸­ï¼‰ã€é€šè·¯å¾…æ©Ÿï¼ˆä¸­å¤®é€šè·¯ã‚¨ãƒªã‚¢é€²å…¥å‰å¾…æ©Ÿï¼‰</p>
            `;
            
            document.getElementById('pathDetails').innerHTML = pathDetails;
            document.getElementById('pathInfo').style.display = 'block';
        }
        
        function generateRobotPathInfo(pathData, robot, robotNum) {
            const sequence = pathData.workSequence;
            let totalDistance = 0;
            
            sequence.forEach(work => {
                totalDistance += LANE_LENGTH * 2 / scale;
            });
            
            for (let i = 0; i < sequence.length - 1; i++) {
                const currentWork = sequence[i];
                const nextWork = sequence[i + 1];
                const currentPoint = getIntersectionPoint(currentWork.area, currentWork.lane);
                const nextPoint = getIntersectionPoint(nextWork.area, nextWork.lane);
                
                const transitionDistance = Math.sqrt(
                    Math.pow(nextPoint.x - currentPoint.x, 2) + 
                    Math.pow(nextPoint.y - currentPoint.y, 2)
                ) / scale;
                
                totalDistance += transitionDistance;
            }
            
            const directionText = pathData.direction === 'right' ? 'æ™‚è¨ˆå›ã‚Š' : 'åæ™‚è¨ˆå›ã‚Š';
            const sequenceText = sequence.map((work, index) => 
                `${index + 1}. ã‚¨ãƒªã‚¢${work.area} é€šè·¯${work.lane}`
            ).join('<br>');
            
            return `
                <div style="flex: 1; border: 2px solid ${robot.color}; padding: 15px; border-radius: 8px;">
                    <h4 style="color: ${robot.color};">ğŸ¤– ${robot.name}</h4>
                    <p><strong>é–‹å§‹ä½ç½®:</strong> ã‚¨ãƒªã‚¢${pathData.startArea} é€šè·¯${pathData.startLane}</p>
                    <p><strong>çµ‚äº†ä½ç½®:</strong> ã‚¨ãƒªã‚¢${pathData.endArea} é€šè·¯${pathData.endLane}</p>
                    <p><strong>å›è»¢æ–¹å‘:</strong> ${directionText}</p>
                    <p><strong>ä½œæ¥­é€šè·¯æ•°:</strong> ${sequence.length}é€šè·¯</p>
                    <p><strong>ç·ç§»å‹•è·é›¢:</strong> ${totalDistance.toFixed(1)}m</p>
                    <p><strong>ä½œæ¥­é †åº:</strong><br>${sequenceText}</p>
                </div>
            `;
        }
        
        // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ç‰ˆã®ã‚¯ãƒªã‚¢å‡¦ç†
        function clearPath() {
            try {
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢
                stopAnimation();
                
                // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
                currentPaths = { robot1: null, robot2: null };
                
                // ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                Object.keys(robots).forEach(robotId => {
                    const robot = robots[robotId];
                    robot.animationPath = [];
                    robot.currentStep = 0;
                    robot.segmentProgress = 0;
                    robot.state = 'idle';
                    robot.waitCounter = 0;
                    robot.x = 0;
                    robot.y = 0;
                    robot.angle = 0;
                    robot.lastUpdateTime = 0;
                });
                
                // UIæ›´æ–°
                drawMap();
                document.getElementById('pathInfo').style.display = 'none';
                document.getElementById('animateBtn').disabled = true;
                
            } catch (error) {
                console.error('ã‚¯ãƒªã‚¢å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // åˆæœŸåŒ–
        drawMap();
    </script>
</body>
</html>